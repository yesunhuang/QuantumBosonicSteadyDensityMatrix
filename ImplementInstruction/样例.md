# 样例

* 以下通过一个经典的样例说明系统是如何运作的。

## 初始化

``initialRho(2,[2,3])``

* 这得到一个四维的矩阵，具体为$(2\times2)\times(3\times3)$
* 根据我们的初始方法，每个矩阵元现在的值都是

$$
\rho_{ij,kl}=\frac{1}{2\times3}=\frac{1}{6}
$$

## 哈密顿量和坍塌算符输入

假设
$$
H=2\hat{a}\hat{a}\hat{b}^\dagger+2\hat{a}^\dagger\hat{a}^\dagger\hat{b}+4\hat{a}+4\hat{a}^\dagger
$$

$$
\hat{O}_1=\hat{a},\gamma_1=2;\hat{O}_2=\hat{b},\gamma_2=4
$$

换言之，用代码表示：

```python
H=[[2,aaB],[2,AAb],[4,A],[4,a]]
C_ops=[[2,a],[4,b]]
defineEvol(H,C_ops)
```

此时，应该有两个数组独立存着系数：

```python
HC=[2j,2j,4j,4j]#乘了一个复数
CC=[1,2]#因为除了2
```



## 预处理方程

那么根据哈密顿算符和坍塌算符，可以得到稳态方程：
$$
0=2i(l+1)\rho_{m(n-2),k(l+1)}+2i(n+1)(n+2)\rho_{m(n+2),k(l-1)}+4i\rho_{m(n-1),kl}+4i(n+1)\rho_{m(n+1),kl}\\-2i(m+1)(m+2)\rho_{(m+2)n,(k-1)l}-2i(k+1)\rho_{(m-2)n,(k+1)l}-4i(m+1)\rho_{(m+1)n,kl}-4i\rho_{(m-1)n,kl}\\
+2(m+1)(n+1)\rho_{(m+1)(n+1),kl}-(m+1)\rho_{mn,kl}-(n+1)\rho_{mn,kl}\\
+2\times2(k+1)(l+1)\rho_{mn,(k+1)(l+1)}-(k+1)\rho_{mn,kl}-(l+1)\rho_{mn,kl}
$$
把索引不变的移到左边，并且合并同类项：
$$
[(n+1)+(m+1)+2(k+1)+2(l+1)]\rho_{mn,kl}=\\2i(l+1)\rho_{m(n-2),k(l+1)}+2i(n+1)(n+2)\rho_{m(n+2),k(l-1)}+4i\rho_{m(n-1),kl}+4i(n+1)\rho_{m(n+1),kl}\\-2i(m+1)(m+2)\rho_{(m+2)n,(k-1)l}-2i(k+1)\rho_{(m-2)n,(k+1)l}-4i(m+1)\rho_{(m+1)n,kl}-4i\rho_{(m-1)n,kl}\\
+2(m+1)(n+1)\rho_{(m+1)(n+1),kl}
+2\times2(k+1)(l+1)\rho_{mn,(k+1)(l+1)}
$$
可选的处理列表方式(其实你们可以考虑建个结构体或者多项式类啥的)如下，一个用来表征乘在当前矩阵元上的多项式：

```python
P_curr=[[CC[0],[0,[0,1]]],[CC[0],[0,[1,0]]],[CC[1]],[1,[0,1]],[CC[1],[1,[1,0]]]]
#[[C_address,[Mode,[m,n]]],...]
```

利用这个表达式对任何输入索引，都能还原出左边那个多项式
$$
P_{curr}(n,m,k,l)=[(n+1)+(m+1)+2(k+1)+2(l+1)]
$$
接着是每个矩阵元的邻居以及他们的系数表达式

```python
Neighbors=[[0,-2,0,1],[0,2,0,-1],[0,-1,0,0],[0,1,0,0],\
           [2,0,-1,0],[-2,0,1,0],[1,0,0,0],[-1,0,0,0],\
           [1,1,0,0],[0,0,1,1]]
#[[m_relative,n_relative,k_relative,l_relative],]
#这个例子中恰好每个邻居的系数表达式都只有一项
P_nbor=[[[HC[0],[0,[0,-2],[1,[0,1]]]]],[[HC[1]],[0,[0,2]],[1,[0,-1]]],\
        [[HC[2],[0,[0,-1]]],[[HC[3],[0,[0,1]]]],...]
#[[[C_adress,[Mode,[m,n]],...],...],...]
```

## 计算方法

### 动态规划

动态规划``DynamicProgram(100,1e-3,[0.3])``

则实现的表达式为
$$
\rho_{mn,kl}=\frac{0.3}{(n+1)+(m+1)+2(k+1)+2(l+1)}\\ [2i(l+1)\rho_{m(n-2),k(l+1)}+2i(n+1)(n+2)\rho_{m(n+2),k(l-1)}+4i\rho_{m(n-1),kl}+4i(n+1)\rho_{m(n+1),kl}\\-2i(m+1)(m+2)\rho_{(m+2)n,(k-1)l}-2i(k+1)\rho_{(m-2)n,(k+1)l}-4i(m+1)\rho_{(m+1)n,kl}-4i\rho_{(m-1)n,kl}\\
+2(m+1)(n+1)\rho_{(m+1)(n+1),kl}
+2\times2(k+1)(l+1)\rho_{mn,(k+1)(l+1)}]\\+0.7\rho_{mn,kl}
$$

## 蒙特卡洛

``MonteTd(1000,1e-3,[0.3,0.8])``假设行进到第一个邻居[0,-2,0,1]，则实现的表达式为
$$
\rho_{mn,kl}=\rho_{mn,kl}+0.3\left[\frac{0.8\times10\times2i(l+1)}{(n+1)+(m+1)+2(k+1)+2(l+1)}\rho_{m(n-2),k(l+1)}-\rho_{mn,kl}\right]
$$

## 输出

输出比较复杂的应该是最后两种。（假设变换和归一化均已做完）

### 分迹矩阵

假设把第二个模式trace掉，``PartialRho([1])``

则$\rho_{ij}^{(ptrace)}=\rho_{ij,00}+\rho_{ij,11}+\rho_{ij,22}$

### 均值矩

```AvgMoment([2,3])`
$$
Moment=0^20^3\rho_{00,00}+1^20^3\rho_{11,00}+0^21^3\rho_{00,11}+1^21^3\rho_{11,11}+0^22^3\rho_{00,22}+1^22^3\rho_{11,22}
$$
